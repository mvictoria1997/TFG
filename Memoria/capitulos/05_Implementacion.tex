\chapter{Implementación}
\label{sec:implementacion}
%Aquí se deben proporcionar los detalles de cómo se ha llevado a la práctica el diseño propuesto en el capítulo anterior. Deben identificarse claramente herramientas, tecnologías, equipamientos, etc. utilizados o necesarios para el buen funcionamiento de la solución. Se pueden describir los fragmentos de código más importantes, con el fin de clarificar la funcionalidad que proporcionan. En general este capítulo debe facilitar la reutilización de nuestra solución, por lo que debe estar bien documentada. Puede incluir un manual de uso.

Aquí se proporcionan los detalles de las funciones implementadas para la ejecución algoritmo UOV, además de la implementación de la aritmética en el cuerpo de 128 elementos.\\

\section{Funciones del cuerpo de 128 elementos}
Las funciones referentes a esta sección son la suma, el producto y conversiones de elementos del cuerpo de $2^7$ elementos a elementos del cuerpo de 128 elementos.\\

Los elementos del cuerpo se representarán con vectores de siete componentes para poder facilitar la implementación de la suma y del producto. Esto se refleja en las dos tablas denominadas \texttt{exp} y \texttt{log}, que tienen la estructura que se muestra en los códigos \ref{cod:exp} y \ref{cod:log}, respectivamente. Para la implementación se han usado las variables diccionario de \texttt{python}, puesto que tienen fácil acceso a todas las componentes.

\vspace{0.25cm}

\begin{lstlisting}[language=Python,caption=Tabla para calcular la potencia en el cuerpo, label=cod:exp]
exp = {
   0 : [0, 0, 0, 0, 0, 0, 1],
   1 : [0, 0, 0, 0, 0, 1, 0],
   125 : [1, 1, 0, 0, 0, 0, 1],
   126 : [1, 0, 0, 0, 0, 0, 1]
}

\end{lstlisting}

\begin{lstlisting}[language=Python,caption=Tabla para calcular el logaritmo en el cuerpo, label=cod:log]
log = {
   tuple( [0, 0, 0, 0, 0, 0, 1] ) : ' 0 ',
   tuple( [0, 0, 0, 0, 0, 1, 0] ) : ' 1 ',
   tuple( [1, 1, 0, 0, 0, 0, 1] ) : ' 125 ',
   tuple( [1, 0, 0, 0, 0, 0, 1] ) : ' 126 ',
}
\end{lstlisting}

La suma de dos elementos del cuerpo se ha implementando la puerta $xor$, esto es si las $iésimas$-componentes son iguales entonces la suma vale $0$, en caso contrario vale $1$, código \ref{cod:suma-cuerpo}.

\vspace{0.25cm}
\begin{lstlisting}[language=Python,caption=Suma de dos elementos del cuerpo, label=cod:suma-cuerpo]
def suma(n1=[], n2=[]):

   suma = []
   for i in range(len(n1)):
      if n1[i] == n2[i]:
         suma += [0]
      else:
         suma += [1]
   return suma
\end{lstlisting}

Para el producto de dos elementos del cuerpo se ha diferenciado el caso en el que uno de los vectores sea $0$ en dicho caso el producto vale 0. Si ninguno de los vectores es $0$ entonces se hace uso de las tablas \ref{cod:exp} y \ref{cod:log}, para trabajar con enteros módulo 127, código \ref{cod:producto-cuerpo}.

\vspace{0.25cm}
\begin{lstlisting}[language=Python,caption=Producto de dos elementos del cuerpo, label=cod:producto-cuerpo]
def product(n1=[], n2=[]):

   product = []
   if (n1 == [0,0,0,0,0,0,0]) or (n2 == [0,0,0,0,0,0,0]):
      product = [0,0,0,0,0,0,0]
   else:
      suma = (int(log.get(tuple(n1))) + int(log.get(tuple(n2))))%127
      product = exp.get(suma)
   return product
\end{lstlisting}


Las siguientes funciones son necesarias para la resolución del sistema de ecuaciones.


Calcula el vector correspondiente vector en el cuerpo de un entero, código \ref{cod:entero-cuerpo}.
\vspace{0.25cm}

\begin{lstlisting}[language=Python,caption=Convierte un entero en un elemento del cuerpo, label=cod:entero-cuerpo]
def F128(n1):

   if n1 == 127:
      return [0,0,0,0,0,0,0]
   else:
      return exp.get(n1)
\end{lstlisting}


Al estar en un cuerpo todo elementos tiene inverso y tiene sentido hacer la función \texttt{inverso} de un elemento del cuerpo, la implementación que se ha hecho ha sido hacer la multiplicación por los restantes elementos y comprobando que de como resultado el elemento unidad, en este caso $[0,0,0,0,0,0,1]$, código \ref{cod:inverso-cuerpo}.
\newpage

%\vspace{0.25cm}
\begin{lstlisting}[language=Python,caption=Inverso de un elemento del cuerpo, label=cod:inverso-cuerpo]
def inverse(n=[]):

   i = 0
   while product(n, F128(i)) != [0,0,0,0,0,0,1]:
      i += 1
   return F128(i)
\end{lstlisting}

La función \texttt{mayor} compara si el elemento $n1$ es mayor que el elemento $n2$, para ello se convierten los vectores a enteros con la tabla \texttt{log} y se compara que entero es mayor, código \ref{cod:mayor-que-cuerpo}.

\vspace{0.25cm}

\begin{lstlisting}[language=Python,caption=Compara dos elementos del cuerpo, label=cod:mayor-que-cuerpo]
def mayor (n1=[],n2=[]):

   if n1 == [0,0,0,0,0,0,0]:
      return False
   else:
      log1, log2 = log.get(tuple(n1)), log.get(tuple(n2))
      return int(log1) > int(log2)
\end{lstlisting}
 


Convierte una matriz $n1$ del cuerpo $\mathds{F}_2$ en un vector $n$ del cuerpo de 128 elementos. Como los elementos de la matriz son solo 0 y 1 la conversión se reduce a, si en la matriz hay un 0 añade al vector $n$ el vector $[0,0,0,0,0,0,0]$ y en otro caso $[0,0,0,0,0,0,1]$, código \ref{cod:matrizF2-cuerpo}.

\vspace{0.25cm}
\begin{lstlisting}[language=Python,caption=Matriz de $\mathds{F}_2$ a un elemento del cuerpo 128 elementos, label=cod:matrizF2-cuerpo]
def matrix_F2to128(n1=[]):

   n =[]
   for i in range(len(n1)):
      row =[]
      for j in range(len(n1[0])):
         if n1[i][j] == 0:
            row += [[0,0,0,0,0,0,0]]
         else:
            row += [[0,0,0,0,0,0,1]]
      n += [row]
   return n
\end{lstlisting}


Convierte un vector de matrices $n1$ del cuerpo $\mathds{F}_2$ en una matriz $matrix$ del cuerpo de 128 elementos. Como en la función anterior los elementos de la matriz son solo 0 y 1, se aplica el mismo cambio, código \ref{cod:matriz3dF2-cuerpo}.

\vspace{0.25cm}

\begin{lstlisting}[language=Python,caption=Vector de matrices de $\mathds{F}_2$ a una matriz del cuerpo de 128 elementos, label=cod:matriz3dF2-cuerpo]
def matrix3d_F2to128(n1=[]):

   matrix =[]
   for i in range(len(n1)):
      n = []
      for j in range(len(n1[0])):
         row = []
         for k in range(len(n1[0][0])):
            if n1[i][j][k] == 0:
               row += [[0,0,0,0,0,0,0]]
               
            else:
               row += [[0,0,0,0,0,0,1]]
         n += [row]
      matrix += [n]
   return matrix
\end{lstlisting}

\section{Funciones con matrices}

En esta sección de explicarán funciones como la suma de matrices, cálculo de la matriz transpuesta, matriz identidad y el producto de matrices tanto en $\mathds{F}_2$ como en el cuerpo de 128 elementos. Además incluye la función que resuelve el sistema de ecuaciones con el método de Gauss-Jordan.\\


Suma de dos matrices $m1$ y $m2$ del cuerpo de 128 elementos, código \ref{cod:suma-matrix}.

\vspace{0.25cm}

\begin{lstlisting}[language=Python,caption=Suma de dos matrices con elementos en el cuerpo, label=cod:suma-matrix]
def matrix_sum (m1, m2):

   m_suma = []

   if (len(m1) == len(m2)) and (len(m1[0]) == len(m2[0])):
      for row in range(len(m1)):
         aux = []
         for col in range(len(m1[0])):
            aux += [suma (m1[row][col], m2[row][col])]
         m_suma += [aux]
   return m_suma
\end{lstlisting}


Producto de dos matrices con elementos en el cuerpo de 128 elementos, código \ref{cod:prod-matrix}.

\vspace{0.25cm}

\begin{lstlisting}[language=Python,caption=Producto de matrices con elementos del cuerpo, label=cod:prod-matrix]
def matrix_product (n1=[], n2=[]):

   prod=[]
   if len(n1[0]) == len(n2):
      for row1 in range(len(n1)):
         aux = []
         for col in range(len(n2[0])):
            p_suma = [0,0,0,0,0,0,0]
            for row2 in range(len(n2)):
               p_suma = suma (product(n1[row1][row2], n2[row2][col]), p_suma)
            aux += [p_suma]
         prod += [aux]
   return prod
\end{lstlisting}

Producto de dos matrices con elementos en el cuerpo $\mathds{F}_2$, como los elementos de la matriz son $0$ y $1$ la suma acomulada se hace con la operación lógica \texttt{xor},  código \ref{cod:prodF2-matrix}.

\vspace{0.25cm}

\begin{lstlisting}[language=Python,caption=Producto de matrices con elementos en $\mathds{F}_2$, label=cod:prodF2-matrix]
def matrix_product_F2 (n1=[], n2=[]):

   prod=[]

   if len(n1[0]) == len(n2):
      for row1 in range(len(n1)):
         aux = []
         for col in range(len(n2[0])):
            p_suma = 0
            for row2 in range(len(n2)):
               p_suma = (n1[row1][row2] * n2[row2][col]) ^ p_suma
            aux += [p_suma]
         prod += [aux]
   return prod
\end{lstlisting}

Calcula la matriz transpuesta de la matriz dada como parámetro, código \ref{cod:trans-matrix}.

\vspace{0.25cm}

\begin{lstlisting}[language=Python,caption=Suma de dos elementos del cuerpo, label=cod:trans-matrix]
def matrix_transpose(m):

   trans = []
   for col in range(len(m[0])):
      aux = []
      for row in range(len(m)):
         aux += [m[row][col]]
      trans += [aux]
   return trans

\end{lstlisting}


Calcula la matriz identidad con una determinada dimensión, $dim$, que se pasa como parámetro, código \ref{cod:identi-matrix}.

\vspace{0.25cm}

\begin{lstlisting}[language=Python,caption=Matriz identidad del cuerpo, label=cod:identi-matrix]
def matrix_identity(dim):

   matrix = []

   for i in range(dim):
      aux = []
      for j in range(dim):
         if i == j:
            aux += [[0,0,0,0,0,0,1]]
         else:
            aux += [[0,0,0,0,0,0,0]]
      matrix += [aux]
   return matrix
\end{lstlisting}


La función \texttt{matrix\_rref} resuelve de un sistema de ecuaciones con el método de Gauss-Jordan, código \ref{cod:Gauss-matrix}.

\vspace{0.25cm}

\begin{lstlisting}[language=Python,caption=Método de Gauss-Jordan, label=cod:Gauss-matrix]
def matrix_rref(A, b):

   r = 0
   pivots_pos = []
   n = len(A)

   #Añadir b como una columna
   M = A
   for row in range(len(M)):
      M[row] += b[row]


   for k in range(n):
      #Intercambio de filas para que quede arriba la de menor valor
      for i in range(k, n):
         if mayor(M[i][k], M[k][k]):
            aux = M[k]
            M[k] = M[i]
            M[i] = aux


      #Hacer ceros
      for j in range(k+1, n):
         q = product(M[j][k], inverse(M[k][k]))
         for m in range(k, n+1):
            M[j][m] = suma(M[j][m], product(q, M[k][m]))


   #Calcular la solución x de abajo arriba
   x = [[[0,0,0,0,0,0,0]] for i in range(n)]

   x[n-1] = [product(M[n-1][n], inverse(M[n-1][n-1]))]
   for i in range(n-1, -1, -1):
      z = [0,0,0,0,0,0,0]
      for j in range(i+1, n):
         z = suma(z, product(M[i][j], x[j][0]))
      x[i] = [product(suma(M[i][n], z), inverse(M[i][i]))]

   return x
\end{lstlisting}

\section{Funciones algoritmo UOV}

La función \texttt{clavePrivada} genera la clave privada de un usuario, para ello genera una matriz triangular superior, $\alpha$, en $\mathds{F}_2$ con valores aleatorios, y un vector, $\beta$, en $\mathds{F}_2$. Los parámetros $m$ y $v$ son el número de variables de aceite y vinagre, respectivamente, código \ref{cod:priv-UOV}.\\

\begin{lstlisting}[language=Python,caption=Generación clave privada, label=cod:priv-UOV]
def clavePrivada (m, v):

   alpha, beta = [], []
   n = m+v

   for k in range(m):
      #alpha matriz triangular superior
      aux = []
      for i in range (v):
         row = []
         for j in range (n):
            if i > j:
               row += [0]
            else:
               if randint(0,1) == 0:
                  row += [0]
               else:
                  row += [1]
         aux += [row]
      alpha += [aux]

      #beta
      row = []
      for i in range(n):
         if randint(0,1) == 0:
            row += [0]
         else:
            row += [1]
      beta += [row]
   return alpha, beta
\end{lstlisting}

La función \texttt{clavePublica} genera la clave pública a partir de la clave privada, calculada con la función anterior, los valores $m$ y $v$ el número de variables de aceite y vinagre, además de una matriz de transación, código \ref{cod:pub-UOV}.\\

\begin{lstlisting}[language=Python,caption=Generación clave pública, label=cod:pub-UOV]
def clavePublica(m, v, alpha, beta, T):

   alpha_pub = []
   beta_pub = []
   T_trans = matrix_transpose(T[0:v])

   for k in range(len(alpha)):
      aux = matrix_product_F2(T_trans , alpha [k])
      alpha_pub += [matrix_product_F2(aux, T)]


      beta_pub += [matrix_product_F2([beta[k]], T)]

   return alpha_pub, beta_pub
\end{lstlisting}

La función \texttt{signature} calcula la firma del hash de un mensaje, $hashed$, con las claves privadas del usuario, $alpha\_F2$ y $beta\_F2$, el número de aceites y vinagres, $m$ y $v$, el tamaño del cuerpo, $r$ y con la matriz de transición, $T$. Se toman los vinagres aleatorios, se resuelve el sistema para calcular los aceites, y con la ecuación \ref{eq:firma} obtenemos la firma del mensaje, código \ref{cod:firma-UOV}.\\

\begin{lstlisting}[language=Python,caption=Firma del mensaje, label=cod:firma-UOV]
def signature(hashed, alpha_F2, beta_F2, m, r, v, T):

   alpha = matrix3d_F2to128(alpha_F2)
   beta = matrix_F2to128(beta_F2)

   vinagre = []
   for k in range(v):
      aux = randint(0, 127)
      vinagre += [F128(aux)]
   coef = []
   term = []

   n= m + v
   for k in range(m):
      A = matrix_product([vinagre], alpha[k])
      coef += matrix_sum([A[0][v:n]], [beta[k][v:n]])
      v_suma = suma (matrix_product([A[0][0:v]], matrix_transpose([vinagre]))[0][0], matrix_product([beta[k][0:v]], matrix_transpose([vinagre]))[0][0])
      term += [suma(hashed[k], v_suma)]


   oil = matrix_rref(coef, matrix_transpose([term]))

   aux = []
   aux += vinagre + matrix_transpose(oil)[0]
   firma = matrix_product([aux], matrix_transpose(matrix_F2to128(T))) #T = T.inverse()
   return firma[0]
\end{lstlisting}

Por último la función \texttt{verify} comprueba si la firma, $firma$, de un mensaje, $m$, es correcta, para ello utiliza las claves públicas del usuario y el número de variables de aceite, se va comprobando una a una si se cumple la igualdad \ref{eq:veri}, código \ref{cod:verif-UOV}.\\

\begin{lstlisting}[language=Python,caption=Verificación de la firma, label=cod:verif-UOV]
def verify(hashed, firma, alpha_pub_F2, beta_pub_F2, m):

   verif = True
   alpha_pub = matrix3d_F2to128(alpha_pub_F2)
   beta_pub = matrix3d_F2to128(beta_pub_F2)
   for k in range(m):
      aux_alpha = matrix_product(matrix_product ([firma], alpha_pub[k]), matrix_transpose([firma]))
      aux_beta = matrix_product (beta_pub[k], matrix_transpose([firma]))
      verif = verif and (hashed[k] == matrix_sum(aux_alpha,  aux_beta)[0][0])

   return verif
\end{lstlisting}


%\begin{lstlisting}[language=Python,caption=Generación clave privada, label=cod:priv-UOV]

%\end{lstlisting}



